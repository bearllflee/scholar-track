// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.4
// source: system.proto

package system

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Casbin_AddPolicy_FullMethodName = "/system.Casbin/AddPolicy"
	Casbin_Enforce_FullMethodName   = "/system.Casbin/Enforce"
)

// CasbinClient is the client API for Casbin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CasbinClient interface {
	AddPolicy(ctx context.Context, in *AddPolicyReq, opts ...grpc.CallOption) (*AddPolicyResp, error)
	Enforce(ctx context.Context, in *EnforceReq, opts ...grpc.CallOption) (*EnforceResp, error)
}

type casbinClient struct {
	cc grpc.ClientConnInterface
}

func NewCasbinClient(cc grpc.ClientConnInterface) CasbinClient {
	return &casbinClient{cc}
}

func (c *casbinClient) AddPolicy(ctx context.Context, in *AddPolicyReq, opts ...grpc.CallOption) (*AddPolicyResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddPolicyResp)
	err := c.cc.Invoke(ctx, Casbin_AddPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *casbinClient) Enforce(ctx context.Context, in *EnforceReq, opts ...grpc.CallOption) (*EnforceResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnforceResp)
	err := c.cc.Invoke(ctx, Casbin_Enforce_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CasbinServer is the server API for Casbin service.
// All implementations must embed UnimplementedCasbinServer
// for forward compatibility.
type CasbinServer interface {
	AddPolicy(context.Context, *AddPolicyReq) (*AddPolicyResp, error)
	Enforce(context.Context, *EnforceReq) (*EnforceResp, error)
	mustEmbedUnimplementedCasbinServer()
}

// UnimplementedCasbinServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCasbinServer struct{}

func (UnimplementedCasbinServer) AddPolicy(context.Context, *AddPolicyReq) (*AddPolicyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPolicy not implemented")
}
func (UnimplementedCasbinServer) Enforce(context.Context, *EnforceReq) (*EnforceResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Enforce not implemented")
}
func (UnimplementedCasbinServer) mustEmbedUnimplementedCasbinServer() {}
func (UnimplementedCasbinServer) testEmbeddedByValue()                {}

// UnsafeCasbinServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CasbinServer will
// result in compilation errors.
type UnsafeCasbinServer interface {
	mustEmbedUnimplementedCasbinServer()
}

func RegisterCasbinServer(s grpc.ServiceRegistrar, srv CasbinServer) {
	// If the following call pancis, it indicates UnimplementedCasbinServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Casbin_ServiceDesc, srv)
}

func _Casbin_AddPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPolicyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasbinServer).AddPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Casbin_AddPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasbinServer).AddPolicy(ctx, req.(*AddPolicyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Casbin_Enforce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnforceReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CasbinServer).Enforce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Casbin_Enforce_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CasbinServer).Enforce(ctx, req.(*EnforceReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Casbin_ServiceDesc is the grpc.ServiceDesc for Casbin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Casbin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "system.Casbin",
	HandlerType: (*CasbinServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddPolicy",
			Handler:    _Casbin_AddPolicy_Handler,
		},
		{
			MethodName: "Enforce",
			Handler:    _Casbin_Enforce_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "system.proto",
}

const (
	Role_AddRole_FullMethodName    = "/system.Role/AddRole"
	Role_DeleteRole_FullMethodName = "/system.Role/DeleteRole"
	Role_UpdateRole_FullMethodName = "/system.Role/UpdateRole"
	Role_RoleTree_FullMethodName   = "/system.Role/RoleTree"
)

// RoleClient is the client API for Role service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 角色服务
type RoleClient interface {
	AddRole(ctx context.Context, in *AddRoleReq, opts ...grpc.CallOption) (*AddRoleResp, error)
	DeleteRole(ctx context.Context, in *DeleteRoleReq, opts ...grpc.CallOption) (*DeleteRoleResp, error)
	UpdateRole(ctx context.Context, in *UpdateRoleReq, opts ...grpc.CallOption) (*UpdateRoleResp, error)
	RoleTree(ctx context.Context, in *RoleTreeReq, opts ...grpc.CallOption) (*RoleTreeListResp, error)
}

type roleClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleClient(cc grpc.ClientConnInterface) RoleClient {
	return &roleClient{cc}
}

func (c *roleClient) AddRole(ctx context.Context, in *AddRoleReq, opts ...grpc.CallOption) (*AddRoleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddRoleResp)
	err := c.cc.Invoke(ctx, Role_AddRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) DeleteRole(ctx context.Context, in *DeleteRoleReq, opts ...grpc.CallOption) (*DeleteRoleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteRoleResp)
	err := c.cc.Invoke(ctx, Role_DeleteRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) UpdateRole(ctx context.Context, in *UpdateRoleReq, opts ...grpc.CallOption) (*UpdateRoleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateRoleResp)
	err := c.cc.Invoke(ctx, Role_UpdateRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleTree(ctx context.Context, in *RoleTreeReq, opts ...grpc.CallOption) (*RoleTreeListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleTreeListResp)
	err := c.cc.Invoke(ctx, Role_RoleTree_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServer is the server API for Role service.
// All implementations must embed UnimplementedRoleServer
// for forward compatibility.
//
// 角色服务
type RoleServer interface {
	AddRole(context.Context, *AddRoleReq) (*AddRoleResp, error)
	DeleteRole(context.Context, *DeleteRoleReq) (*DeleteRoleResp, error)
	UpdateRole(context.Context, *UpdateRoleReq) (*UpdateRoleResp, error)
	RoleTree(context.Context, *RoleTreeReq) (*RoleTreeListResp, error)
	mustEmbedUnimplementedRoleServer()
}

// UnimplementedRoleServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRoleServer struct{}

func (UnimplementedRoleServer) AddRole(context.Context, *AddRoleReq) (*AddRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRole not implemented")
}
func (UnimplementedRoleServer) DeleteRole(context.Context, *DeleteRoleReq) (*DeleteRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}
func (UnimplementedRoleServer) UpdateRole(context.Context, *UpdateRoleReq) (*UpdateRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRole not implemented")
}
func (UnimplementedRoleServer) RoleTree(context.Context, *RoleTreeReq) (*RoleTreeListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleTree not implemented")
}
func (UnimplementedRoleServer) mustEmbedUnimplementedRoleServer() {}
func (UnimplementedRoleServer) testEmbeddedByValue()              {}

// UnsafeRoleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServer will
// result in compilation errors.
type UnsafeRoleServer interface {
	mustEmbedUnimplementedRoleServer()
}

func RegisterRoleServer(s grpc.ServiceRegistrar, srv RoleServer) {
	// If the following call pancis, it indicates UnimplementedRoleServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Role_ServiceDesc, srv)
}

func _Role_AddRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).AddRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_AddRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).AddRole(ctx, req.(*AddRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_DeleteRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).DeleteRole(ctx, req.(*DeleteRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_UpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).UpdateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_UpdateRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).UpdateRole(ctx, req.(*UpdateRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleTreeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Role_RoleTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleTree(ctx, req.(*RoleTreeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Role_ServiceDesc is the grpc.ServiceDesc for Role service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Role_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "system.Role",
	HandlerType: (*RoleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddRole",
			Handler:    _Role_AddRole_Handler,
		},
		{
			MethodName: "DeleteRole",
			Handler:    _Role_DeleteRole_Handler,
		},
		{
			MethodName: "UpdateRole",
			Handler:    _Role_UpdateRole_Handler,
		},
		{
			MethodName: "RoleTree",
			Handler:    _Role_RoleTree_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "system.proto",
}

const (
	User_QueryUserDetail_FullMethodName    = "/system.User/QueryUserDetail"
	User_QueryUserList_FullMethodName      = "/system.User/QueryUserList"
	User_FindUserByUsername_FullMethodName = "/system.User/FindUserByUsername"
	User_Register_FullMethodName           = "/system.User/Register"
	User_SetUserInfo_FullMethodName        = "/system.User/SetUserInfo"
	User_SetSelfInfo_FullMethodName        = "/system.User/SetSelfInfo"
	User_QuerySelfInfo_FullMethodName      = "/system.User/QuerySelfInfo"
	User_SetUserRole_FullMethodName        = "/system.User/SetUserRole"
	User_ResetPassword_FullMethodName      = "/system.User/ResetPassword"
	User_ChangePassword_FullMethodName     = "/system.User/ChangePassword"
	User_DeleteUser_FullMethodName         = "/system.User/DeleteUser"
)

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	QueryUserDetail(ctx context.Context, in *QueryUserDetailReq, opts ...grpc.CallOption) (*QueryUserDetailResp, error)
	QueryUserList(ctx context.Context, in *QueryUserListReq, opts ...grpc.CallOption) (*QueryUserListResp, error)
	FindUserByUsername(ctx context.Context, in *FindUserByUsernameReq, opts ...grpc.CallOption) (*FindUserByUsernameResp, error)
	Register(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*RegisterResp, error)
	SetUserInfo(ctx context.Context, in *SetUserInfoReq, opts ...grpc.CallOption) (*SetUserInfoResp, error)
	SetSelfInfo(ctx context.Context, in *SetSelfInfoReq, opts ...grpc.CallOption) (*SetSelfInfoResp, error)
	QuerySelfInfo(ctx context.Context, in *QuerySelfInfoReq, opts ...grpc.CallOption) (*QuerySelfInfoResp, error)
	SetUserRole(ctx context.Context, in *SetUserRoleReq, opts ...grpc.CallOption) (*SetUserRoleResp, error)
	ResetPassword(ctx context.Context, in *ResetPasswordReq, opts ...grpc.CallOption) (*ResetPasswordResp, error)
	ChangePassword(ctx context.Context, in *ChangePasswordReq, opts ...grpc.CallOption) (*ChangePasswordResp, error)
	DeleteUser(ctx context.Context, in *DeleteUserReq, opts ...grpc.CallOption) (*DeleteUserResp, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) QueryUserDetail(ctx context.Context, in *QueryUserDetailReq, opts ...grpc.CallOption) (*QueryUserDetailResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryUserDetailResp)
	err := c.cc.Invoke(ctx, User_QueryUserDetail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) QueryUserList(ctx context.Context, in *QueryUserListReq, opts ...grpc.CallOption) (*QueryUserListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryUserListResp)
	err := c.cc.Invoke(ctx, User_QueryUserList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) FindUserByUsername(ctx context.Context, in *FindUserByUsernameReq, opts ...grpc.CallOption) (*FindUserByUsernameResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindUserByUsernameResp)
	err := c.cc.Invoke(ctx, User_FindUserByUsername_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) Register(ctx context.Context, in *RegisterReq, opts ...grpc.CallOption) (*RegisterResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterResp)
	err := c.cc.Invoke(ctx, User_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetUserInfo(ctx context.Context, in *SetUserInfoReq, opts ...grpc.CallOption) (*SetUserInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserInfoResp)
	err := c.cc.Invoke(ctx, User_SetUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetSelfInfo(ctx context.Context, in *SetSelfInfoReq, opts ...grpc.CallOption) (*SetSelfInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetSelfInfoResp)
	err := c.cc.Invoke(ctx, User_SetSelfInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) QuerySelfInfo(ctx context.Context, in *QuerySelfInfoReq, opts ...grpc.CallOption) (*QuerySelfInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QuerySelfInfoResp)
	err := c.cc.Invoke(ctx, User_QuerySelfInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) SetUserRole(ctx context.Context, in *SetUserRoleReq, opts ...grpc.CallOption) (*SetUserRoleResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetUserRoleResp)
	err := c.cc.Invoke(ctx, User_SetUserRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ResetPassword(ctx context.Context, in *ResetPasswordReq, opts ...grpc.CallOption) (*ResetPasswordResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResetPasswordResp)
	err := c.cc.Invoke(ctx, User_ResetPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) ChangePassword(ctx context.Context, in *ChangePasswordReq, opts ...grpc.CallOption) (*ChangePasswordResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangePasswordResp)
	err := c.cc.Invoke(ctx, User_ChangePassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) DeleteUser(ctx context.Context, in *DeleteUserReq, opts ...grpc.CallOption) (*DeleteUserResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserResp)
	err := c.cc.Invoke(ctx, User_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility.
type UserServer interface {
	QueryUserDetail(context.Context, *QueryUserDetailReq) (*QueryUserDetailResp, error)
	QueryUserList(context.Context, *QueryUserListReq) (*QueryUserListResp, error)
	FindUserByUsername(context.Context, *FindUserByUsernameReq) (*FindUserByUsernameResp, error)
	Register(context.Context, *RegisterReq) (*RegisterResp, error)
	SetUserInfo(context.Context, *SetUserInfoReq) (*SetUserInfoResp, error)
	SetSelfInfo(context.Context, *SetSelfInfoReq) (*SetSelfInfoResp, error)
	QuerySelfInfo(context.Context, *QuerySelfInfoReq) (*QuerySelfInfoResp, error)
	SetUserRole(context.Context, *SetUserRoleReq) (*SetUserRoleResp, error)
	ResetPassword(context.Context, *ResetPasswordReq) (*ResetPasswordResp, error)
	ChangePassword(context.Context, *ChangePasswordReq) (*ChangePasswordResp, error)
	DeleteUser(context.Context, *DeleteUserReq) (*DeleteUserResp, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserServer struct{}

func (UnimplementedUserServer) QueryUserDetail(context.Context, *QueryUserDetailReq) (*QueryUserDetailResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUserDetail not implemented")
}
func (UnimplementedUserServer) QueryUserList(context.Context, *QueryUserListReq) (*QueryUserListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryUserList not implemented")
}
func (UnimplementedUserServer) FindUserByUsername(context.Context, *FindUserByUsernameReq) (*FindUserByUsernameResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindUserByUsername not implemented")
}
func (UnimplementedUserServer) Register(context.Context, *RegisterReq) (*RegisterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedUserServer) SetUserInfo(context.Context, *SetUserInfoReq) (*SetUserInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUserInfo not implemented")
}
func (UnimplementedUserServer) SetSelfInfo(context.Context, *SetSelfInfoReq) (*SetSelfInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSelfInfo not implemented")
}
func (UnimplementedUserServer) QuerySelfInfo(context.Context, *QuerySelfInfoReq) (*QuerySelfInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QuerySelfInfo not implemented")
}
func (UnimplementedUserServer) SetUserRole(context.Context, *SetUserRoleReq) (*SetUserRoleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUserRole not implemented")
}
func (UnimplementedUserServer) ResetPassword(context.Context, *ResetPasswordReq) (*ResetPasswordResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedUserServer) ChangePassword(context.Context, *ChangePasswordReq) (*ChangePasswordResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (UnimplementedUserServer) DeleteUser(context.Context, *DeleteUserReq) (*DeleteUserResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}
func (UnimplementedUserServer) testEmbeddedByValue()              {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	// If the following call pancis, it indicates UnimplementedUserServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_QueryUserDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserDetailReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).QueryUserDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_QueryUserDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).QueryUserDetail(ctx, req.(*QueryUserDetailReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_QueryUserList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUserListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).QueryUserList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_QueryUserList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).QueryUserList(ctx, req.(*QueryUserListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_FindUserByUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindUserByUsernameReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).FindUserByUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_FindUserByUsername_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).FindUserByUsername(ctx, req.(*FindUserByUsernameReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).Register(ctx, req.(*RegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SetUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetUserInfo(ctx, req.(*SetUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetSelfInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSelfInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetSelfInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SetSelfInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetSelfInfo(ctx, req.(*SetSelfInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_QuerySelfInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySelfInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).QuerySelfInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_QuerySelfInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).QuerySelfInfo(ctx, req.(*QuerySelfInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_SetUserRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUserRoleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).SetUserRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_SetUserRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).SetUserRole(ctx, req.(*SetUserRoleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetPasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ResetPassword(ctx, req.(*ResetPasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangePasswordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_ChangePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).ChangePassword(ctx, req.(*ChangePasswordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: User_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).DeleteUser(ctx, req.(*DeleteUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "system.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "QueryUserDetail",
			Handler:    _User_QueryUserDetail_Handler,
		},
		{
			MethodName: "QueryUserList",
			Handler:    _User_QueryUserList_Handler,
		},
		{
			MethodName: "FindUserByUsername",
			Handler:    _User_FindUserByUsername_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _User_Register_Handler,
		},
		{
			MethodName: "SetUserInfo",
			Handler:    _User_SetUserInfo_Handler,
		},
		{
			MethodName: "SetSelfInfo",
			Handler:    _User_SetSelfInfo_Handler,
		},
		{
			MethodName: "QuerySelfInfo",
			Handler:    _User_QuerySelfInfo_Handler,
		},
		{
			MethodName: "SetUserRole",
			Handler:    _User_SetUserRole_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _User_ResetPassword_Handler,
		},
		{
			MethodName: "ChangePassword",
			Handler:    _User_ChangePassword_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _User_DeleteUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "system.proto",
}
