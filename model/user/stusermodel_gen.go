// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.3

package user

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/bearllflee/scholar-track/user/user"
	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	stUserFieldNames          = builder.RawFieldNames(&StUser{})
	stUserRows                = strings.Join(stUserFieldNames, ",")
	stUserRowsExpectAutoSet   = strings.Join(stringx.Remove(stUserFieldNames, "`id`", "`created_at`", "`created_time`", "`created_at`", "`updated_at`", "`updated_time`", "`updated_at`", "`deleted_at`", "`avatar`"), ",")
	stUserRowsWithPlaceHolder = strings.Join(stringx.Remove(stUserFieldNames, "`id`", "`created_at`", "`created_time`", "`created_at`", "`updated_at`", "`updated_time`", "`updated_at`"), "=?,") + "=?"

	cacheStUserIdPrefix = "cache:stUser:id:"
)

type (
	stUserModel interface {
		Insert(ctx context.Context, data *StUser) (sql.Result, error)
		FindOne(ctx context.Context, id int64) (*StUser, error)
		Update(ctx context.Context, data *StUser) error
		Delete(ctx context.Context, id int64) error
		FindUserList(ctx context.Context, in *user.QueryUserListReq) (int64, []*StUser, error)
		FindUserByUsername(ctx context.Context, username string) (*StUser, error)
	}

	defaultStUserModel struct {
		sqlc.CachedConn
		table string
	}

	StUser struct {
		Id        int64          `db:"id"`
		CreatedAt time.Time      `db:"created_at"` // 创建时间
		UpdatedAt time.Time      `db:"updated_at"` // 修改时间
		DeletedAt sql.NullTime   `db:"deleted_at"` // 删除时间
		Username  string         `db:"username"`   // 学号
		Email     sql.NullString `db:"email"`      // 邮箱
		Avatar    sql.NullString `db:"avatar"`     // 头像
		Role      int64          `db:"role"`       // 角色id
		Status    int64          `db:"status"`     // 账户状态（0不可用，1可用）
		Nickname  sql.NullString `db:"nickname"`   // 用户昵称
		Phone     sql.NullString `db:"phone"`      // 电话号码
		Gender    int64          `db:"gender"`     // 性别（0女，1男）
		Major     string         `db:"major"`      // 专业
		College   string         `db:"college"`    // 学院
		Grade     string         `db:"grade"`      // 年级
		Class     string         `db:"class"`      // 班级
		Realname  string         `db:"realname"`   // 姓名
		Password  string         `db:"password"`   // 密码
	}
)

func newStUserModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultStUserModel {
	return &defaultStUserModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`st_user`",
	}
}

func (m *defaultStUserModel) Delete(ctx context.Context, id int64) error {
	stUserIdKey := fmt.Sprintf("%s%v", cacheStUserIdPrefix, id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, stUserIdKey)
	return err
}

func (m *defaultStUserModel) FindOne(ctx context.Context, id int64) (*StUser, error) {
	stUserIdKey := fmt.Sprintf("%s%v", cacheStUserIdPrefix, id)
	var resp StUser
	err := m.QueryRowCtx(ctx, &resp, stUserIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? and `deleted_at` is null limit 1", stUserRows, m.table)
		fmt.Println(query)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultStUserModel) Insert(ctx context.Context, data *StUser) (sql.Result, error) {
	stUserIdKey := fmt.Sprintf("%s%v", cacheStUserIdPrefix, data.Id)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, stUserRowsExpectAutoSet)
		fmt.Println(query)
		return conn.ExecCtx(ctx, query, data.Username, data.Email, data.Role, data.Status, data.Nickname, data.Phone, data.Gender, data.Major, data.College, data.Grade, data.Class, data.Realname, data.Password)
	}, stUserIdKey)
	return ret, err
}

func (m *defaultStUserModel) Update(ctx context.Context, data *StUser) error {
	stUserIdKey := fmt.Sprintf("%s%v", cacheStUserIdPrefix, data.Id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, stUserRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, data.DeletedAt, data.Username, data.Email, data.Avatar, data.Role, data.Status, data.Nickname, data.Phone, data.Gender, data.Major, data.College, data.Grade, data.Class, data.Realname, data.Id)
	}, stUserIdKey)
	return err
}
func (m *defaultStUserModel) FindUserList(ctx context.Context, in *user.QueryUserListReq) (int64, []*StUser, error) {
	var conditions []string
	var args []any
	if in.Username != "" {
		conditions = append(conditions, "username like ?")
		args = append(args, "%"+in.Username+"%")
	}
	if in.Email != "" {
		conditions = append(conditions, "email like ?")
		args = append(args, "%"+in.Email+"%")
	}
	if in.Phone != "" {
		conditions = append(conditions, "phone like ?")
		args = append(args, "%"+in.Phone+"%")
	}
	if in.Nickname != "" {
		conditions = append(conditions, "nickname like ?")
		args = append(args, "%"+in.Nickname+"%")
	}
	if in.Realname != "" {
		conditions = append(conditions, "realname like ?")
		args = append(args, "%"+in.Realname+"%")
	}
	if in.Status != 0 {
		conditions = append(conditions, "status = ?")
		args = append(args, in.Status)
	}
	if in.Role != 0 {
		conditions = append(conditions, "role = ?")
		args = append(args, in.Role)
	}
	if in.Gender != 0 {
		conditions = append(conditions, "gender = ?")
		args = append(args, in.Gender)
	}
	if in.Major != "" {
		conditions = append(conditions, "major = ?")
		args = append(args, in.Major)
	}
	if in.College != "" {
		conditions = append(conditions, "college = ?")
		args = append(args, in.College)
	}
	if in.Grade != "" {
		conditions = append(conditions, "grade = ?")
		args = append(args, in.Grade)
	}
	if in.Class != "" {
		conditions = append(conditions, "class = ?")
		args = append(args, in.Class)
	}
	// 排序
	orderBy := "created_at desc"
	if in.OrderBy != "" {
		orderBy = in.OrderBy
	}
	whereClause := "where `deleted_at` is null"
	if len(conditions) > 0 {
		whereClause += " and " + strings.Join(conditions, " and ")
	}
	query := fmt.Sprintf("select %s from %s %s order by %s limit ?, ?", stUserRows, m.table, whereClause, orderBy)
	fmt.Println(query)
	// select `id`,`created_at`,`updated_at`,`deleted_at`,`username`,`email`,`avatar`,`role`,`status`,`nickname`,
	// `phone`,`gender`,`major`,`college`,`grade`,`class`,`realname` from `st_user` where `deleted_at`
	// is null and username like ? order by created_at desc limit ?, ?
	var total int64
	err := m.QueryRowNoCacheCtx(ctx, &total, "select count(*) from "+m.table+" "+whereClause, args...)
	if err != nil {
		return 0, nil, err
	}
	args = append(args, (in.Page-1)*in.PageSize, in.PageSize)
	var resp []*StUser

	err = m.QueryRowsNoCacheCtx(ctx, &resp, query, args...)
	if err != nil {
		return 0, nil, err
	}
	return total, resp, nil
}

func (m *defaultStUserModel) FindUserByUsername(ctx context.Context, username string) (*StUser, error) {
	query := fmt.Sprintf("select %s from %s where `username` = ? and `deleted_at` is null limit 1", stUserRows, m.table)
	var resp StUser
	err := m.QueryRowNoCacheCtx(ctx, &resp, query, username)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultStUserModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheStUserIdPrefix, primary)
}

func (m *defaultStUserModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", stUserRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultStUserModel) tableName() string {
	return m.table
}
